import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
import numpy as np
from pathlib import Path

# Page config
st.set_page_config(
    page_title="Fantasy Football Dashboard",
    page_icon="üèà",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Custom CSS for better styling
st.markdown("""
<style>
    .main-header {
        font-size: 3rem;
        color: #1f77b4;
        text-align: center;
        margin-bottom: 2rem;
    }
    .metric-container {
        background-color: #f0f2f6;
        padding: 1rem;
        border-radius: 0.5rem;
        margin: 0.5rem 0;
    }
</style>
""", unsafe_allow_html=True)

# Add this helper function for trend lines if statsmodels is available
def add_trendline_if_available(fig, df, x_col, y_col):
    """Add trend line if statsmodels is available, otherwise skip"""
    try:
        import statsmodels.api as sm
        import numpy as np
        
        # Calculate trend line manually
        x = df[x_col].values
        y = df[y_col].values
        
        # Remove any NaN values
        mask = ~(np.isnan(x) | np.isnan(y))
        x_clean = x[mask]
        y_clean = y[mask]
        
        if len(x_clean) > 1:
            # Add constant for intercept
            X = sm.add_constant(x_clean)
            model = sm.OLS(y_clean, X).fit()
            
            # Create trend line
            x_trend = np.linspace(x_clean.min(), x_clean.max(), 100)
            y_trend = model.params[0] + model.params[1] * x_trend
            
            # Add trend line to figure
            fig.add_scatter(
                x=x_trend, 
                y=y_trend,
                mode='lines',
                name='Trend',
                line=dict(color='red', dash='dash'),
                showlegend=False
            )
    except ImportError:
        # statsmodels not available, skip trend line
        pass
    except Exception:
        # Any other error, skip trend line
        pass
    
    return fig

@st.cache_data
def load_all_data():
    """Load all CSV files from data folder"""
    data_dir = Path("data")
    file_path = "data/2021-2024_stats.csv"
    # if file_path.exists():
    master_df = pd.read_csv(file_path)
    
    # Fix missing position data for Free Agents
    if not master_df.empty and 'position' in master_df.columns:
        master_df = fix_free_agent_positions(master_df)
    
    # Load ADP data (optional)
    adp_files = ["ADP_2022.csv", "ADP_2023.csv", "ADP_2024.csv", "ADP_2025.csv"]
    adp_data = []
    for filename in adp_files:
        file_path = data_dir / filename
        if file_path.exists():
            df = pd.read_csv(file_path)
            adp_data.append(df)
    
    adp_df = pd.concat(adp_data, ignore_index=True) if adp_data else pd.DataFrame()
    
    return master_df, adp_df

# Move widget to main code
debug_mode = st.sidebar.checkbox("üîç Debug Draft Data", value=False)

@st.cache_data
def load_draft_data():
    """
    Load draft data from CSV (generated by Yahoo API function)
    Expected columns: year, round, pick, team_name, player_name, position, season_points
    """
    draft_data_path = Path("data/2021-2024_draft_results.csv")
    
    if draft_data_path.exists():
        draft_df = pd.read_csv(draft_data_path)
        
        return draft_df
    else:
        # Return empty DataFrame with expected structure
        return pd.DataFrame(columns=[
            'year', 'round', 'pick', 'team_name', 
            'player_name', 'position', 'season_points'
        ])

# Then use the widget result outside
draft_df = load_draft_data()

if debug_mode:
    st.write("Debugging enabled.")
    st.dataframe(draft_df)
    # Debug: Show actual columns in sidebar
    if st.sidebar.checkbox("üîç Debug Draft Data", value=False):
        st.sidebar.write("**Draft CSV Columns:**")
        st.sidebar.write(list(draft_df.columns))
        st.sidebar.write("**Draft CSV Shape:**")
        st.sidebar.write(draft_df.shape)
        st.sidebar.write("**First few rows:**")
        st.sidebar.dataframe(draft_df.head(3))

def fix_free_agent_positions(df):
    """
    Fix missing position data for Free Agent players by forward-filling 
    their position from when they were rostered
    """
    # Create a copy to avoid modifying original
    df = df.copy()
    
    # Sort by player and week to ensure proper order for forward fill
    df = df.sort_values(['player_name_full', 'year', 'week'])
    
    # Forward fill position for each player within each year
    df['position'] = df.groupby(['player_name_full', 'year'])['position'].ffill()
    
    # If still missing (player was never rostered that year), try across years
    df['position'] = df.groupby('player_name_full')['position'].ffill()
    
    # For any remaining missing positions, try backward fill
    df['position'] = df.groupby('player_name_full')['position'].bfill()
    
    # If still missing, we can make educated guesses based on other stats
    df = guess_missing_positions(df)
    
    return df

def guess_missing_positions(df):
    """
    Make educated guesses for any remaining missing positions based on stats
    """
    missing_pos = df['position'].isna()
    
    if missing_pos.sum() > 0:
        # For players with passing stats, likely QB
        is_qb = (df['Pass Yds'].notna() & (df['Pass Yds'] > 0)) | (df['Pass TD'].notna() & (df['Pass TD'] > 0))
        df.loc[missing_pos & is_qb, 'position'] = 'QB'
        
        # For players with only kicking stats, likely K
        is_kicker = ((df['FG 0-19'].notna() & (df['FG 0-19'] > 0)) | 
                    (df['FG 20-29'].notna() & (df['FG 20-29'] > 0)) |
                    (df['FG 30-39'].notna() & (df['FG 30-39'] > 0)) |
                    (df['FG 40-49'].notna() & (df['FG 40-49'] > 0)) |
                    (df['FG 50+'].notna() & (df['FG 50+'] > 0)) |
                    (df['PAT Made'].notna() & (df['PAT Made'] > 0)))
        df.loc[missing_pos & is_kicker, 'position'] = 'K'
        
        # For players with defensive stats, likely DEF
        is_def = ((df['Sack'].notna() & (df['Sack'] > 0)) |
                 (df['Fum Rec'].notna() & (df['Fum Rec'] > 0)) |
                 (df['Safe'].notna() & (df['Safe'] > 0)) |
                 (df['Pts Allow 0'].notna()))
        df.loc[missing_pos & is_def, 'position'] = 'DEF'
        
        # For players with receiving stats but no passing, likely WR
        is_wr = ((df['Rec'].notna() & (df['Rec'] > 0)) | 
                (df['Rec Yds'].notna() & (df['Rec Yds'] > 0)) |
                (df['Rec TD'].notna() & (df['Rec TD'] > 0))) & ~is_qb
        df.loc[missing_pos & is_wr, 'position'] = 'WR'
        
        # For players with rushing stats but no passing/receiving, likely RB
        is_rb = ((df['Rush Yds'].notna() & (df['Rush Yds'] > 0)) |
                (df['Rush TD'].notna() & (df['Rush TD'] > 0))) & ~is_qb & ~is_wr
        df.loc[missing_pos & is_rb, 'position'] = 'RB'
        
        # For any remaining missing positions, assign 'UNKNOWN'
        df['position'] = df['position'].fillna('UNKNOWN')
    
    return df

# ALL YOUR ANALYSIS FUNCTIONS IN ONE PLACE
def calculate_avg_points_per_player(df):
    """Analysis 1: Average points per player"""
    avg_points_per_player = df.groupby(['player_name_full', 'position']).agg({
        'player_fantasy_pts': ['mean', 'count', 'std'],
        'year': 'first'
    }).round(2)
    
    avg_points_per_player.columns = ['avg_points_per_week', 'games_played', 'std_dev', 'year']
    avg_points_per_player = avg_points_per_player.reset_index()
    avg_points_per_player = avg_points_per_player[avg_points_per_player['games_played'] >= 4]
    
    return avg_points_per_player.sort_values('avg_points_per_week', ascending=False)

def calculate_avg_points_per_position(df):
    """Analysis 3: Average points per position"""
    avg_points_by_position = df.groupby(['position', 'year']).agg({
        'player_fantasy_pts': ['mean', 'median', 'count'],
        'player_name_full': 'nunique'
    }).round(2)
    
    avg_points_by_position.columns = ['mean_points', 'median_points', 'total_games', 'unique_players']
    return avg_points_by_position.reset_index()

def calculate_position_volatility(df):
    """Analysis 4: Position volatility"""
    position_volatility = df.groupby(['position', 'year']).agg({
        'player_fantasy_pts': ['std', 'mean', 'min', 'max']
    }).round(2)
    
    position_volatility.columns = ['std_dev_points', 'mean_points', 'min_points', 'max_points']
    position_volatility = position_volatility.reset_index()
    position_volatility['coeff_of_variation'] = position_volatility['std_dev_points'] / position_volatility['mean_points']
    
    return position_volatility

def create_player_tiers_by_position(df, method='natural_breaks'):
    """
    Analysis 6: Player tiers using natural breakpoints instead of quartiles
    Tier 1 = Best players, Tier 4 = Worst players
    """
    player_season_avg = df.groupby(['player_name_full', 'position', 'year']).agg({
        'player_fantasy_pts': 'mean',
        'week': 'count'
    }).reset_index()
    
    player_season_avg = player_season_avg[player_season_avg['week'] >= 8]
    
    def assign_natural_tiers(group):
        if len(group) < 8:  # Need minimum players for meaningful tiers
            return group
            
        # Sort by fantasy points (descending)
        group = group.sort_values('player_fantasy_pts', ascending=False)
        group['rank'] = range(1, len(group) + 1)
        
        # Natural breakpoint percentiles by position type
        pos = group['position'].iloc[0]
        
        if pos in ['QB', 'TE']:  # Shallow positions
            tier_breaks = [0.15, 0.40, 0.75, 1.0]  # 15%, 25%, 35%, 25%
        elif pos in ['K', 'DEF']:  # Very shallow
            tier_breaks = [0.20, 0.50, 0.80, 1.0]  # 20%, 30%, 30%, 20%
        else:  # RB, WR - deeper positions
            tier_breaks = [0.10, 0.30, 0.65, 1.0]  # 10%, 20%, 35%, 35%
        
        # Calculate actual cutoff points
        n_players = len(group)
        tier_cutoffs = [int(n_players * pct) for pct in tier_breaks]
        
        # Assign tiers
        conditions = [
            group['rank'] <= tier_cutoffs[0],
            group['rank'] <= tier_cutoffs[1], 
            group['rank'] <= tier_cutoffs[2],
            group['rank'] <= tier_cutoffs[3]
        ]
        
        choices = ['Tier 1', 'Tier 2', 'Tier 3', 'Tier 4']
        group['tier'] = np.select(conditions, choices, default='Tier 4')
        
        return group
    
    player_tiers = player_season_avg.groupby(['position', 'year']).apply(assign_natural_tiers).reset_index(drop=True)
    return player_tiers

def create_player_rank_analysis(df):
    """
    Create yearly player rankings for scatterplot
    Each player gets a rank within their position for each year they played
    """
    # Calculate season totals (not averages) for ranking
    player_season_totals = df.groupby(['player_name_full', 'position', 'year']).agg({
        'player_fantasy_pts': 'sum',  # Total points for the year
        'week': 'count'  # Games played
    }).reset_index()
    
    # Filter for significant playing time
    player_season_totals = player_season_totals[player_season_totals['week'] >= 4]
    
    # Calculate overall rank across all positions for each year
    def assign_overall_rank(group):
        group = group.sort_values('player_fantasy_pts', ascending=False)
        group['overall_rank'] = range(1, len(group) + 1)
        return group
    
    ranked_players = player_season_totals.groupby('year').apply(assign_overall_rank).reset_index(drop=True)
    
    return ranked_players

def create_team_analysis(df):
    """Analysis 7: Team analysis"""
    team_performance = df.groupby(['team_name', 'year']).agg({
        'player_fantasy_pts': 'sum',
        'week': 'nunique'
    }).reset_index()
    
    team_performance['avg_points_per_week'] = team_performance['player_fantasy_pts'] / team_performance['week']
    return team_performance

def analyze_positional_scarcity(df):
    """
    Analyze which positions have the biggest drop-off from elite to average players
    This helps determine draft strategy: where is elite talent most scarce?
    """
    # Calculate season averages for each player
    player_season_avg = df.groupby(['player_name_full', 'position', 'year']).agg({
        'player_fantasy_pts': 'mean',
        'week': 'count'
    }).reset_index()
    
    # Filter for significant playing time (8+ games)
    player_season_avg = player_season_avg[player_season_avg['week'] >= 8]
    
    scarcity_analysis = []
    
    for position in player_season_avg['position'].unique():
        pos_data = player_season_avg[player_season_avg['position'] == position]
        
        if len(pos_data) < 10:  # Need sufficient sample
            continue
            
        # Sort by fantasy points (descending)
        pos_data = pos_data.sort_values('player_fantasy_pts', ascending=False)
        
        # Calculate key percentiles
        total_players = len(pos_data)
        
        # Elite tier (top 5%)
        elite_cutoff = max(1, int(total_players * 0.05))
        elite_avg = pos_data.head(elite_cutoff)['player_fantasy_pts'].mean()
        
        # Top tier (top 10%) 
        top10_cutoff = max(1, int(total_players * 0.10))
        top10_avg = pos_data.head(top10_cutoff)['player_fantasy_pts'].mean()
        
        # Starter tier (top 25% - "average starters")
        starter_cutoff = max(1, int(total_players * 0.25))
        starter_avg = pos_data.head(starter_cutoff)['player_fantasy_pts'].mean()
        
        # Mid-tier (25th-50th percentile)
        mid_start = starter_cutoff
        mid_end = max(1, int(total_players * 0.50))
        mid_avg = pos_data.iloc[mid_start:mid_end]['player_fantasy_pts'].mean()
        
        # Replacement level (50th-75th percentile)
        replacement_start = mid_end
        replacement_end = max(1, int(total_players * 0.75))
        replacement_avg = pos_data.iloc[replacement_start:replacement_end]['player_fantasy_pts'].mean()
        
        # Calculate drop-offs
        elite_to_starter_drop = elite_avg - starter_avg
        elite_to_mid_drop = elite_avg - mid_avg
        top10_to_starter_drop = top10_avg - starter_avg
        starter_to_replacement_drop = starter_avg - replacement_avg
        
        scarcity_analysis.append({
            'position': position,
            'total_players': total_players,
            'elite_avg': round(elite_avg, 1),
            'top10_avg': round(top10_avg, 1),
            'starter_avg': round(starter_avg, 1),
            'mid_avg': round(mid_avg, 1),
            'replacement_avg': round(replacement_avg, 1),
            'elite_to_starter_drop': round(elite_to_starter_drop, 1),
            'elite_to_mid_drop': round(elite_to_mid_drop, 1),
            'top10_to_starter_drop': round(top10_to_starter_drop, 1),
            'starter_to_replacement_drop': round(starter_to_replacement_drop, 1),
            'elite_count': elite_cutoff,
            'top10_count': top10_cutoff,
            'starter_count': starter_cutoff
        })
    
    return pd.DataFrame(scarcity_analysis)

def analyze_elite_vs_depth_strategy(df):
    """
    Compare teams that drafted elite QBs vs teams that went RB/WR heavy early
    """
    # This would need team draft data and season results
    # For now, we'll simulate the analysis conceptually
    
    # Calculate positional value above replacement
    player_season_avg = df.groupby(['player_name_full', 'position', 'year']).agg({
        'player_fantasy_pts': 'mean',
        'week': 'count'
    }).reset_index()
    
    player_season_avg = player_season_avg[player_season_avg['week'] >= 8]
    
    # Calculate value above replacement for each position
    var_analysis = []
    
    for position in player_season_avg['position'].unique():
        pos_data = player_season_avg[player_season_avg['position'] == position]
        
        if len(pos_data) < 10:
            continue
            
        # Sort by points
        pos_data = pos_data.sort_values('player_fantasy_pts', ascending=False)
        
        # Replacement level = 75th percentile
        replacement_cutoff = int(len(pos_data) * 0.75)
        replacement_level = pos_data.iloc[replacement_cutoff]['player_fantasy_pts']
        
        # Calculate value above replacement for each player
        pos_data['value_above_replacement'] = pos_data['player_fantasy_pts'] - replacement_level
        
        # Get elite players (top 5%)
        elite_count = max(1, int(len(pos_data) * 0.05))
        elite_var = pos_data.head(elite_count)['value_above_replacement'].mean()
        
        var_analysis.append({
            'position': position,
            'replacement_level': round(replacement_level, 1),
            'elite_var': round(elite_var, 1),
            'elite_count': elite_count
        })
    
    return pd.DataFrame(var_analysis)

# DRAFT ANALYSIS FUNCTIONS
def analyze_draft_strategy_effectiveness(draft_df):
    """
    Analyze which draft strategies led to better team performance
    """
    if draft_df.empty:
        return pd.DataFrame()
    
    # Calculate team season totals
    team_season_totals = draft_df.groupby(['team_name', 'year']).agg({
        'season_points': 'sum'
    }).reset_index()
    
    # Calculate early round position preferences by team
    early_rounds = draft_df[draft_df['round'] <= 3]  # First 3 rounds
    
    # Count picks by position in early rounds
    early_position_strategy = early_rounds.groupby(['team_name', 'year', 'position']).size().reset_index(name='early_picks')
    
    # Pivot to get positions as columns
    strategy_pivot = early_position_strategy.pivot_table(
        index=['team_name', 'year'], 
        columns='position', 
        values='early_picks', 
        fill_value=0
    ).reset_index()
    
    # Merge with team performance
    strategy_performance = team_season_totals.merge(
        strategy_pivot, 
        on=['team_name', 'year'], 
        how='left'
    ).fillna(0)
    
    return strategy_performance

def analyze_draft_value_picks(draft_df, adp_df, selected_years):
    """
    Find the biggest steals and reaches compared to ADP
    """
    if draft_df.empty or adp_df.empty:
        return pd.DataFrame(), pd.DataFrame()
    
    # Filter by selected years
    draft_df_filtered = draft_df[draft_df['year'].isin(selected_years)]
    adp_df_filtered = adp_df[adp_df['year'].isin(selected_years)]
    
    # Merge draft picks with ADP
    draft_with_adp = draft_df_filtered.merge(
        adp_df_filtered[['Player', 'AVG Draft Position', 'year']], 
        left_on=['player_name', 'year'],
        right_on=['Player', 'year'],
        how='inner'
    )
    
    if draft_with_adp.empty:
        return pd.DataFrame(), pd.DataFrame()
    
    # Calculate reach/steal amount
    draft_with_adp['adp_diff'] = draft_with_adp['pick'] - draft_with_adp['AVG Draft Position']
    
    # Calculate value score (performance relative to draft position)
    draft_with_adp['value_score'] = draft_with_adp['season_points'] / draft_with_adp['pick']
    
    # Biggest steals (drafted later than ADP, performed well)
    steals = draft_with_adp[
        (draft_with_adp['adp_diff'] > 12) &  # Drafted 12+ picks later than ADP
        (draft_with_adp['season_points'] > draft_with_adp['season_points'].quantile(0.6))
    ].nlargest(10, 'value_score')
    
    # Biggest reaches (drafted earlier than ADP, underperformed)  
    reaches = draft_with_adp[
        (draft_with_adp['adp_diff'] < -12) &  # Drafted 12+ picks earlier than ADP
        (draft_with_adp['season_points'] < draft_with_adp['season_points'].quantile(0.4))
    ].nsmallest(10, 'value_score')
    
    return steals, reaches

def create_draft_scatterplot_with_dynamic_trendline(draft_df, selected_positions):
    """
    Create draft scatterplot with trend line that updates based on selected positions
    """
    # Filter draft data by selected positions
    filtered_draft_df = draft_df[draft_df['position'].isin(selected_positions)]
    
    if filtered_draft_df.empty:
        return go.Figure().add_annotation(
            text="No data available for selected positions",
            xref="paper", yref="paper", x=0.5, y=0.5, showarrow=False
        )
    
    # Create the scatterplot
    fig = px.scatter(
        filtered_draft_df,
        x='pick',
        y='season_points', 
        color='position',
        hover_data=['player_name', 'year', 'team_name', 'round'],
        title='Draft Position vs Season Points in Your League',
        labels={
            'pick': 'Draft Position in Your League',
            'season_points': 'Total Fantasy Points for Season',
            'position': 'Position'
        },
        height=500
    )
    
    # Add trend line using numpy polyfit
    try:
        import numpy as np
        
        x = filtered_draft_df['pick'].values
        y = filtered_draft_df['season_points'].values
        
        # Remove any NaN values
        mask = ~(np.isnan(x) | np.isnan(y))
        x_clean = x[mask]
        y_clean = y[mask]
        
        if len(x_clean) > 1:
            # Calculate trend line
            z = np.polyfit(x_clean, y_clean, 1)
            p = np.poly1d(z)
            
            # Create trend line points
            x_trend = np.linspace(x_clean.min(), x_clean.max(), 100)
            y_trend = p(x_trend)
            
            # Add trend line to figure
            fig.add_scatter(
                x=x_trend, 
                y=y_trend,
                mode='lines',
                name=f'Trend ({len(selected_positions)} positions)',
                line=dict(color='red', dash='dash', width=2),
                showlegend=True
            )
            
            # Calculate and display R-squared
            correlation_matrix = np.corrcoef(x_clean, y_clean)
            correlation = correlation_matrix[0,1]
            r_squared = correlation**2
            
            # Add R-squared annotation
            fig.add_annotation(
                x=0.02,
                y=0.98,
                xref="paper",
                yref="paper",
                text=f"R¬≤ = {r_squared:.3f}",
                showarrow=False,
                font=dict(size=12, color="red"),
                bgcolor="white",
                bordercolor="red",
                borderwidth=1
            )
    
    except ImportError:
        # numpy not available, skip trend line
        pass
    except Exception:
        # Any other error, skip trend line
        pass
    
    fig.update_layout(
        xaxis_title="Draft Position (1 = First Pick)",
        yaxis_title="Total Fantasy Points for Season"
    )
    
    return fig

# MAIN DASHBOARD
def main():
    st.title("üèà Fantasy Football Analytics Dashboard")
    
    # Debug mode toggle
    debug_mode = st.sidebar.checkbox("üêõ Debug Mode", value=False)
    
    if debug_mode:
        st.sidebar.subheader("üîç Debug Info")
        st.sidebar.write(f"Current working directory: {Path.cwd()}")
        st.sidebar.write(f"Data directory exists: {Path('data').exists()}")
        if Path('data').exists():
            csv_files = list(Path('data').glob("*.csv"))
            st.sidebar.write(f"CSV files found: {[f.name for f in csv_files]}")
    
    # Load data
    master_df, adp_df = load_all_data()
    
    if master_df.empty:
        st.error("‚ùå No data found! Make sure your CSV files are in the 'data' folder.")
        return
    
    # Sidebar controls
    st.sidebar.header("üéõÔ∏è Controls")
    
    # Year checkboxes
    st.sidebar.subheader("üìÖ Select Years")
    years = sorted(master_df['year'].unique())
    selected_years = []
    
    cols = st.sidebar.columns(len(years))
    for i, year in enumerate(years):
        with cols[i]:
            if st.checkbox(str(year), value=True, key=f"year_{year}"):
                selected_years.append(year)
    
    # Position multi-select - fix data type issues
    positions = master_df['position'].dropna().astype(str).unique()
    positions = sorted([pos for pos in positions if pos != 'nan'])
    selected_positions = st.sidebar.multiselect(
        "üèÉ‚Äç‚ôÇÔ∏è Select Positions",
        positions,
        default=positions
    )
    
    if not selected_years or not selected_positions:
        st.warning("‚ö†Ô∏è Please select at least one year and position.")
        return
    
    # Filter data
    filtered_df = master_df[
        (master_df['year'].isin(selected_years)) & 
        (master_df['position'].isin(selected_positions))
    ]
    
    # Data summary
    st.sidebar.markdown("---")
    st.sidebar.metric("üìä Total Records", len(filtered_df))
    st.sidebar.metric("üë§ Unique Players", filtered_df['player_name_full'].nunique())
    st.sidebar.metric("üèÜ Teams", filtered_df['team_name'].nunique())
    
    # Main dashboard tabs
    tab1, tab2, tab3, tab4, tab5 = st.tabs([
        "üìä Position Analysis", 
        "üë§ Player Analysis", 
        "üèÜ Team Analysis",
        "üìà Draft Analysis", 
        "üéØ Advanced Metrics"
    ])
    
    with tab1:
        st.header("üìä Position Analysis")
        
        col1, col2 = st.columns(2)
        
        with col1:
            # Average points by position
            avg_by_pos = calculate_avg_points_per_position(filtered_df)
            fig1 = px.bar(avg_by_pos, x='position', y='mean_points', 
                         color='year', barmode='group',
                         title='Average Points by Position')
            st.plotly_chart(fig1, use_container_width=True, key="avg_points_pos")
        
        with col2:
            # Position volatility
            vol_by_pos = calculate_position_volatility(filtered_df)
            fig2 = px.line(vol_by_pos, x='position', y='coeff_of_variation', 
                          color='year', markers=True,
                          title='Position Volatility (Coefficient of Variation)')
            st.plotly_chart(fig2, use_container_width=True, key="pos_volatility")
        
        # Position summary table
        st.subheader("Position Summary")
        summary = filtered_df.groupby('position').agg({
            'player_fantasy_pts': ['mean', 'std', 'count'],
            'player_name_full': 'nunique'
        }).round(2)
        summary.columns = ['Avg Points', 'Std Dev', 'Total Games', 'Unique Players']
        st.dataframe(summary, use_container_width=True)
    
    with tab2:
        st.header("üë§ Player Analysis")
        
        # Create player rankings for scatterplot
        ranked_players = create_player_rank_analysis(filtered_df)
        
        # Top section: New scatterplot
        st.subheader("üéØ Player Performance by Rank (Multi-Year View)")
        st.write("Each dot represents one player's season. Players who played multiple years have multiple dots.")
        
        if not ranked_players.empty:
            # Create the scatterplot
            fig_scatter = px.scatter(
                ranked_players, 
                x='overall_rank', 
                y='player_fantasy_pts',
                color='position',
                hover_data=['player_name_full', 'year', 'week'],
                title='Fantasy Points vs Overall Rank by Position',
                labels={
                    'overall_rank': 'Overall Rank (1 = Best)',
                    'player_fantasy_pts': 'Total Fantasy Points for Season',
                    'position': 'Position'
                },
                height=500
            )
            
            # Customize the chart
            fig_scatter.update_layout(
                xaxis_title="Overall Rank (1 = Highest Scoring Player)",
                yaxis_title="Total Fantasy Points for Season",
                showlegend=True
            )
            
            # Reverse x-axis so rank 1 is on the left
            fig_scatter.update_xaxes(autorange="reversed")
            
            st.plotly_chart(fig_scatter, use_container_width=True, key="player-rank-scatter")
            
            # Add insights below the chart
            col1, col2, col3 = st.columns(3)
            
            with col1:
                top_scorer = ranked_players.loc[ranked_players['player_fantasy_pts'].idxmax()]
                st.metric(
                    "üèÜ Highest Single Season", 
                    f"{top_scorer['player_name_full']}", 
                    f"{top_scorer['player_fantasy_pts']:.1f} pts ({top_scorer['year']})"
                )
            
            with col2:
                multi_year_players = ranked_players['player_name_full'].value_counts()
                most_consistent = multi_year_players.max()
                st.metric("üìÖ Max Years Played", most_consistent, f"by {multi_year_players.idxmax()}")
            
            with col3:
                avg_top10 = ranked_players[ranked_players['overall_rank'] <= 10]['player_fantasy_pts'].mean()
                st.metric("üéØ Top 10 Avg Points", f"{avg_top10:.1f}")
        
        # Bottom section: Existing analysis
        col1, col2 = st.columns(2)
        
        with col1:
            st.subheader("üèÖ Top 20 Players by Average Points")
            player_avg = calculate_avg_points_per_player(filtered_df)
            top_20 = player_avg.head(20)
            
            fig3 = px.scatter(top_20, x='games_played', y='avg_points_per_week',
                             color='position', size='avg_points_per_week',
                             hover_data=['player_name_full'],
                             title='Top Players: Avg Points vs Games Played')
            st.plotly_chart(fig3, use_container_width=True, key="top-players-scatter")
            
            st.dataframe(top_20[['player_name_full', 'position', 'avg_points_per_week', 'games_played']], 
                        use_container_width=True)
        
        with col2:
            st.subheader("üèÜ Player Tiers (Natural Breakpoints)")
            st.write("Tier 1 = Elite, Tier 4 = Replacement Level")
            
            # Create improved tiers
            if len(filtered_df) > 50:  # Only if enough data
                tiers = create_player_tiers_by_position(filtered_df)
                if not tiers.empty and 'tier' in tiers.columns:
                    
                    # Show tier distribution
                    tier_counts = tiers.groupby(['position', 'tier']).size().reset_index(name='count')
                    fig4 = px.bar(tier_counts, x='position', y='count', 
                                 color='tier', 
                                 title='Player Tier Distribution by Position',
                                 color_discrete_map={
                                     'Tier 1': '#1f77b4',  # Blue
                                     'Tier 2': '#ff7f0e',  # Orange  
                                     'Tier 3': '#2ca02c',  # Green
                                     'Tier 4': '#d62728'   # Red
                                 })
                    st.plotly_chart(fig4, use_container_width=True, key="tier-distribution")
                    
                    # Show tier stats
                    tier_stats = tiers.groupby(['position', 'tier']).agg({
                        'player_fantasy_pts': ['mean', 'count']
                    }).round(1)
                    tier_stats.columns = ['Avg Points', 'Player Count']
                    st.dataframe(tier_stats, use_container_width=True)
                else:
                    st.info("Insufficient data for tier analysis")
            else:
                st.info("Need more data for tier analysis")
    
    with tab3:
        st.header("üèÜ Team Analysis")
        
        if 'team_name' in filtered_df.columns:
            team_stats = create_team_analysis(filtered_df)
            
            col1, col2 = st.columns(2)
            
            with col1:
                fig5 = px.histogram(team_stats, x='avg_points_per_week', 
                                   title='Team Performance Distribution')
                st.plotly_chart(fig5, use_container_width=True, key="team_perf_dist")
            
            with col2:
                fig6 = px.bar(team_stats.nlargest(10, 'avg_points_per_week'), 
                             x='team_name', y='avg_points_per_week',
                             color='year', title='Top 10 Teams')
                st.plotly_chart(fig6, use_container_width=True, key="top_10_teams")
            
            st.dataframe(team_stats.sort_values('avg_points_per_week', ascending=False), 
                        use_container_width=True)
        else:
            st.info("Team data not available in current dataset")
    
    with tab4:
        st.header("üìà Draft Analysis")
        
        # Load draft data
        draft_df = load_draft_data()
        
        if draft_df.empty:
            st.info("üîÑ Draft data not available yet.")
            st.write("**To generate draft data:**")
            st.code("""
# 1. Run the Yahoo API draft function once to generate CSV:
get_league_draft_results(weekly_stats_df)

# 2. This creates data/draft_results.csv with columns:
# year, round, pick, overall_pick, team_name, player_name, position, season_points

# 3. Dashboard will automatically load the CSV file
            """)
            
            st.write("**What you'll see once draft data is added:**")
            st.write("- Draft position vs performance scatterplots")
            st.write("- Draft strategy effectiveness analysis")
            st.write("- Biggest steals and reaches vs ADP")
            st.write("- Team drafting performance comparison")
            
        else:
            # Create tabs for different analyses
            draft_overview_tab, strategy_tab, value_tab = st.tabs([
                "üìä Draft Overview", 
                "üß† Strategy Analysis", 
                "üíé Value Analysis"
            ])
            
            with draft_overview_tab:
                st.subheader("üèà Your League Draft Results")
                
                # Check required columns
                required_cols = ['pick', 'season_points', 'position', 'player_name', 'year', 'team_name', 'round']
                missing_cols = [col for col in required_cols if col not in draft_df.columns]
                
                if missing_cols:
                    st.error(f"‚ùå Missing required columns in draft data: {missing_cols}")
                    st.write("**Available columns:**", list(draft_df.columns))
                    st.write("**Expected columns:**", required_cols)
                    return
                
                # Draft position vs performance scatterplot
                # try:
                #     fig_league_scatter = px.scatter(
                #         draft_df,
                #         x='pick',
                #         y='season_points', 
                #         color='position',
                #         hover_data=['player_name', 'year', 'team_name', 'round'],
                #         title='Draft Position vs Season Points in Your League',
                #         labels={
                #             'pick': 'Draft Position in Your League',
                #             'season_points': 'Total Fantasy Points for Season',
                #             'position': 'Position'
                #         },
                #         height=500
                #     )
                    
                #     fig_league_scatter.update_layout(
                #         xaxis_title="Draft Position (1 = First Pick)",
                #         yaxis_title="Total Fantasy Points for Season"
                #     )
                    
                #     # Try to add trend line if possible
                #     fig_league_scatter = add_trendline_if_available(
                #         fig_league_scatter, draft_df, 'pick', 'season_points'
                #     )
                    
                #     st.plotly_chart(fig_league_scatter, use_container_width=True)

                # Draft position vs performance scatterplot
                try:
                    fig_league_scatter = create_draft_scatterplot_with_dynamic_trendline(
                        draft_df, selected_positions
                    )
                    st.plotly_chart(fig_league_scatter, use_container_width=True, key="draft-scatterplot")

                except Exception as e:
                    st.error(f"‚ùå Error creating scatterplot: {e}")
                    st.write("**Debug info:**")
                    st.write("Draft DF info:")
                    st.dataframe(draft_df.head())
                
                # Draft insights
                col1, col2, col3, col4 = st.columns(4)
                
                with col1:
                    best_value = draft_df.loc[draft_df['season_points'].idxmax()]
                    st.metric(
                        "üèÜ Highest Scorer", 
                        f"{best_value['player_name']}", 
                        f"Pick {best_value['pick']} ‚Üí {best_value['season_points']:.0f} pts"
                    )
                
                with col2:
                    late_picks = draft_df[draft_df['pick'] > 60]
                    if not late_picks.empty:
                        best_late = late_picks.loc[late_picks['season_points'].idxmax()]
                        st.metric(
                            "üíé Best Late Pick", 
                            f"{best_late['player_name']}", 
                            f"Pick {best_late['pick']} ‚Üí {best_late['season_points']:.0f} pts"
                        )
                
                with col3:
                    round1_avg = draft_df[draft_df['round'] == 1]['season_points'].mean()
                    st.metric(
                        "üìä Round 1 Average", 
                        f"{round1_avg:.0f} points", 
                        "Expected from early picks"
                    )
                
                with col4:
                    team_totals = draft_df.groupby('team_name')['season_points'].sum()
                    best_team = team_totals.idxmax()
                    best_team_total = team_totals.max()
                    st.metric(
                        "üèÜ Best Drafting Team", 
                        best_team, 
                        f"{best_team_total:.0f} total pts"
                    )
                
                with col1:
                    best_value = draft_df.loc[draft_df['season_points'].idxmax()]
                    st.metric(
                        "üèÜ Highest Scorer", 
                        f"{best_value['player_name']}", 
                        f"Pick {best_value['pick']} ‚Üí {best_value['season_points']:.0f} pts"
                    )
                
                with col2:
                    late_picks = draft_df[draft_df['pick'] > 60]
                    if not late_picks.empty:
                        best_late = late_picks.loc[late_picks['season_points'].idxmax()]
                        st.metric(
                            "üíé Best Late Pick", 
                            f"{best_late['player_name']}", 
                            f"Pick {best_late['pick']} ‚Üí {best_late['season_points']:.0f} pts"
                        )
                
                with col3:
                    round1_avg = draft_df[draft_df['round'] == 1]['season_points'].mean()
                    st.metric(
                        "üìä Round 1 Average", 
                        f"{round1_avg:.0f} points", 
                        "Expected from early picks"
                    )
                
                with col4:
                    team_totals = draft_df.groupby('team_name')['season_points'].sum()
                    best_team = team_totals.idxmax()
                    best_team_total = team_totals.max()
                    st.metric(
                        "üèÜ Best Drafting Team", 
                        best_team, 
                        f"{best_team_total:.0f} total pts"
                    )
                
                # Draft round analysis table
                st.subheader("üìä Your League Performance by Draft Round")
                league_round_analysis = draft_df.groupby('round').agg({
                    'season_points': ['mean', 'std', 'count'],
                    'player_name': 'nunique'
                }).round(1)
                league_round_analysis.columns = ['Avg Points', 'Std Dev', 'Total Picks', 'Unique Players']
                st.dataframe(league_round_analysis, use_container_width=True)
            
            with strategy_tab:
                st.subheader("üß† Draft Strategy Effectiveness")
                
                strategy_performance = analyze_draft_strategy_effectiveness(draft_df)
                
                if not strategy_performance.empty:
                    # QB early vs late strategy
                    if 'QB' in strategy_performance.columns:
                        fig_qb_strategy = px.scatter(
                            strategy_performance, 
                            x='QB', 
                            y='season_points',
                            hover_data=['team_name', 'year'],
                            title='Early QB Picks vs Total Team Points',
                            labels={
                                'QB': 'QBs Drafted in First 3 Rounds',
                                'season_points': 'Total Team Points'
                            }
                        )
                        st.plotly_chart(fig_qb_strategy, use_container_width=True, key="qb-strategy")
                    
                    # RB heavy vs balanced strategy
                    if 'RB' in strategy_performance.columns:
                        fig_rb_strategy = px.scatter(
                            strategy_performance, 
                            x='RB', 
                            y='season_points',
                            hover_data=['team_name', 'year'],
                            title='Early RB Picks vs Total Team Points',
                            labels={
                                'RB': 'RBs Drafted in First 3 Rounds',
                                'season_points': 'Total Team Points'
                            }
                        )
                        st.plotly_chart(fig_rb_strategy, use_container_width=True, key="rb-strategy")
                    
                    # Strategy summary table
                    st.subheader("üìä Strategy Performance Summary")
                    if all(col in strategy_performance.columns for col in ['QB', 'RB', 'WR']):
                        strategy_summary = strategy_performance.groupby(['QB', 'RB', 'WR']).agg({
                            'season_points': ['mean', 'count']
                        }).round(1)
                        strategy_summary.columns = ['Avg Points', 'Times Used']
                        st.dataframe(strategy_summary)
                    else:
                        st.info("Need more draft data for strategy analysis")
                else:
                    st.info("Draft strategy analysis requires more data")
            
            with value_tab:
                st.subheader("üíé Draft Value Analysis")
                
                if not adp_df.empty:
                    steals, reaches = analyze_draft_value_picks(draft_df, adp_df, selected_years)
                    
                    col1, col2 = st.columns(2)
                    
                    with col1:
                        st.write("**üèÜ Biggest Steals vs ADP**")
                        if not steals.empty:
                            steal_display = steals[['player_name', 'pick', 'AVG Draft Position', 'adp_diff', 'season_points', 'team_name', 'year']]
                            steal_display.columns = ['Player', 'Your Pick', 'ADP', 'Rounds Later', 'Points', 'Team', 'Year']
                            st.dataframe(steal_display)
                        else:
                            st.info("No significant steals found")
                    
                    with col2:
                        st.write("**üí∏ Biggest Reaches vs ADP**")
                        if not reaches.empty:
                            reach_display = reaches[['player_name', 'pick', 'AVG Draft Position', 'adp_diff', 'season_points', 'team_name', 'year']]
                            reach_display.columns = ['Player', 'Your Pick', 'ADP', 'Rounds Early', 'Points', 'Team', 'Year']
                            st.dataframe(reach_display)
                        else:
                            st.info("No significant reaches found")
                    
                    # ADP accuracy analysis
                    st.subheader("üéØ League vs ADP Accuracy")
                    
                    league_vs_adp = draft_df.merge(
                        adp_df[adp_df['year'].isin(selected_years)][['Player', 'AVG Draft Position', 'year']], 
                        left_on=['player_name', 'year'],
                        right_on=['Player', 'year'],
                        how='inner'
                    )
                    
                    if not league_vs_adp.empty:
                        league_vs_adp['adp_diff'] = league_vs_adp['pick'] - league_vs_adp['AVG Draft Position']
                        
                        fig_adp_diff = px.histogram(
                            league_vs_adp, 
                            x='adp_diff', 
                            title='League Draft Position vs ADP Difference',
                            labels={'adp_diff': 'Picks Different from ADP (+ = Later, - = Earlier)'}
                        )
                        st.plotly_chart(fig_adp_diff, use_container_width=True, key="adp-diff-histogram")
                        
                        # Show comparison with global ADP
                        col1, col2 = st.columns(2)
                        
                        with col1:
                            st.write("**üåç Global ADP vs Performance**")
                            if not adp_df.empty:
                                # Create ADP performance analysis
                                all_years_performance = filtered_df.groupby(['player_name_full', 'position', 'year']).agg({
                                    'player_fantasy_pts': 'sum',
                                    'week': 'count'
                                }).reset_index()
                                
                                all_years_performance = all_years_performance[all_years_performance['week'] >= 4]

                                # Filter ADP data by selected years
                                adp_df_filtered = adp_df[adp_df['year'].isin(selected_years)]

                                adp_performance = all_years_performance.merge(
                                    adp_df_filtered[['Player', 'AVG Draft Position', 'year']], 
                                    left_on=['player_name_full', 'year'],
                                    right_on=['Player', 'year'],
                                    how='inner'
                                )
                                
                                if not adp_performance.empty:
                                    fig_adp_scatter = px.scatter(
                                        adp_performance,
                                        x='AVG Draft Position',
                                        y='player_fantasy_pts', 
                                        color='position',
                                        hover_data=['player_name_full', 'year'],
                                        title='Global ADP vs Performance',
                                        labels={
                                            'AVG Draft Position': 'ADP',
                                            'player_fantasy_pts': 'Season Points'
                                        },
                                        height=400
                                    )
                                    st.plotly_chart(fig_adp_scatter, use_container_width=True, key="adp-performance-scatter")

                        with col2:
                            st.write("**üèà Your League vs ADP**")
                            fig_league_vs_adp = px.scatter(
                                league_vs_adp,
                                x='AVG Draft Position',
                                y='pick',
                                color='position',
                                hover_data=['player_name', 'year', 'team_name'],
                                title='Your Picks vs Global ADP',
                                labels={
                                    'AVG Draft Position': 'Global ADP',
                                    'pick': 'Your League Pick'
                                },
                                height=400
                            )
                            # Add diagonal line for perfect ADP match
                            min_val = min(league_vs_adp['AVG Draft Position'].min(), league_vs_adp['pick'].min())
                            max_val = max(league_vs_adp['AVG Draft Position'].max(), league_vs_adp['pick'].max())
                            fig_league_vs_adp.add_shape(
                                type="line",
                                x0=min_val, y0=min_val,
                                x1=max_val, y1=max_val,
                                line=dict(color="gray", dash="dash")
                            )
                            st.plotly_chart(fig_league_vs_adp, use_container_width=True, key="league-vs-adp-scatter")
                    else:
                        st.warning("‚ö†Ô∏è No matching data between draft and ADP files")
                else:
                    st.info("ADP data required for value analysis")

    with tab5:
        st.header("üéØ Advanced Metrics & Draft Strategy")
        
        # Positional Scarcity Analysis
        st.subheader("üíé Positional Scarcity Analysis")
        st.write("**Key Question:** Which positions have the biggest drop-off from elite to average players?")
        
        scarcity_df = analyze_positional_scarcity(filtered_df)
        
        if not scarcity_df.empty:
            # Create the key visualization: Elite to Starter drop-off
            fig_scarcity = px.bar(
                scarcity_df.sort_values('elite_to_starter_drop', ascending=False),
                x='position', 
                y='elite_to_starter_drop',
                title='Points Drop-off: Elite (Top 5%) to Average Starter (Top 25%)',
                labels={
                    'elite_to_starter_drop': 'Points Drop-off per Game',
                    'position': 'Position'
                },
                color='elite_to_starter_drop',
                color_continuous_scale='Reds'
            )
            fig_scarcity.update_layout(height=400)
            st.plotly_chart(fig_scarcity, use_container_width=True, key="fig_scarcity_tab5")
            
            # Show the scarcity table
            st.subheader("üìä Positional Depth Analysis")
            
            # Select key columns for display
            display_cols = [
                'position', 'elite_avg', 'top10_avg', 'starter_avg', 'mid_avg',
                'elite_to_starter_drop', 'top10_to_starter_drop', 'elite_count'
            ]
            
            scarcity_display = scarcity_df[display_cols].sort_values('elite_to_starter_drop', ascending=False)
            
            # Rename columns for clarity
            scarcity_display.columns = [
                'Position', 'Elite Avg (Top 5%)', 'Top 10% Avg', 'Starter Avg (Top 25%)', 
                'Mid-Tier Avg', 'Elite‚ÜíStarter Drop', 'Top10‚ÜíStarter Drop', '# Elite Players'
            ]
            
            st.dataframe(scarcity_display, use_container_width=True)
            
            # Strategic insights
            st.subheader("üß† Strategic Insights")
            
            col1, col2, col3 = st.columns(3)
            
            with col1:
                most_scarce = scarcity_df.loc[scarcity_df['elite_to_starter_drop'].idxmax()]
                st.metric(
                    "üèÜ Most Scarce Position", 
                    most_scarce['position'],
                    f"{most_scarce['elite_to_starter_drop']} pt drop-off"
                )
            
            with col2:
                deepest_pos = scarcity_df.loc[scarcity_df['elite_to_starter_drop'].idxmin()]
                st.metric(
                    "üìä Deepest Position", 
                    deepest_pos['position'],
                    f"{deepest_pos['elite_to_starter_drop']} pt drop-off"
                )
            
            with col3:
                # Calculate which position has most elite options
                most_elite = scarcity_df.loc[scarcity_df['elite_count'].idxmax()]
                st.metric(
                    "üéØ Most Elite Options", 
                    most_elite['position'],
                    f"{most_elite['elite_count']} elite players"
                )
            
            # Draft strategy recommendations
            st.subheader("üìà Draft Strategy Implications")
            
            # Sort by scarcity
            scarcity_sorted = scarcity_df.sort_values('elite_to_starter_drop', ascending=False)
            
            st.write("**Based on positional scarcity analysis:**")
            
            most_scarce_pos = scarcity_sorted.iloc[0]['position']
            second_scarce_pos = scarcity_sorted.iloc[1]['position'] if len(scarcity_sorted) > 1 else "N/A"
            deepest_pos = scarcity_sorted.iloc[-1]['position']
            
            st.info(f"""
            üéØ **Priority 1:** Target elite {most_scarce_pos}s early - biggest drop-off from elite to average
            
            üéØ **Priority 2:** Consider elite {second_scarce_pos}s if available
            
            üéØ **Wait Strategy:** {deepest_pos} position has good depth - can wait until later rounds
            
            üìä **The Data Says:** Elite {most_scarce_pos}s provide {scarcity_sorted.iloc[0]['elite_to_starter_drop']:.1f} more points per game than average starters
            """)
        
        # Value Above Replacement Analysis
        st.subheader("‚ö° Value Above Replacement (VAR)")
        var_df = analyze_elite_vs_depth_strategy(filtered_df)
        
        if not var_df.empty:
            fig_var = px.bar(
                var_df.sort_values('elite_var', ascending=False),
                x='position',
                y='elite_var', 
                title='Elite Player Value Above Replacement Level',
                labels={
                    'elite_var': 'Points Above Replacement per Game',
                    'position': 'Position'
                }
            )
            st.plotly_chart(fig_var, use_container_width=True, key="fig_var_tab5")
            
            st.dataframe(var_df, use_container_width=True)
        
        # Weekly trends
        st.subheader("üìÖ Weekly Scoring Trends")
        weekly_trends = filtered_df.groupby(['week', 'position'])['player_fantasy_pts'].mean().reset_index()
        fig7 = px.line(weekly_trends, x='week', y='player_fantasy_pts',
                      color='position', title='Average Points by Week and Position')
        st.plotly_chart(fig7, use_container_width=True, key="weekly-trends")
        # val,
        #                         line=dict(color="gray", dash="dash")
        #                     )
        #                     st.plotly_chart(fig_league_vs_adp, use_container_width=True)
        #             else:
        #                 st.warning("‚ö†Ô∏è No matching data between draft and ADP files")
        #         else:
        #             st.info("ADP data required for value analysis")

    with tab5:
        st.header("üéØ Advanced Metrics & Draft Strategy")
        
        # Positional Scarcity Analysis
        st.subheader("üíé Positional Scarcity Analysis")
        st.write("**Key Question:** Which positions have the biggest drop-off from elite to average players?")
        
        scarcity_df = analyze_positional_scarcity(filtered_df)
        
        if not scarcity_df.empty:
            # Create the key visualization: Elite to Starter drop-off
            fig_scarcity = px.bar(
                scarcity_df.sort_values('elite_to_starter_drop', ascending=False),
                x='position', 
                y='elite_to_starter_drop',
                title='Points Drop-off: Elite (Top 5%) to Average Starter (Top 25%)',
                labels={
                    'elite_to_starter_drop': 'Points Drop-off per Game',
                    'position': 'Position'
                },
                color='elite_to_starter_drop',
                color_continuous_scale='Reds'
            )
            fig_scarcity.update_layout(height=400)
            st.plotly_chart(fig_scarcity, use_container_width=True, key="fig_scarcity")
            
            # Show the scarcity table
            st.subheader("üìä Positional Depth Analysis")
            
            # Select key columns for display
            display_cols = [
                'position', 'elite_avg', 'top10_avg', 'starter_avg', 'mid_avg',
                'elite_to_starter_drop', 'top10_to_starter_drop', 'elite_count'
            ]
            
            scarcity_display = scarcity_df[display_cols].sort_values('elite_to_starter_drop', ascending=False)
            
            # Rename columns for clarity
            scarcity_display.columns = [
                'Position', 'Elite Avg (Top 5%)', 'Top 10% Avg', 'Starter Avg (Top 25%)', 
                'Mid-Tier Avg', 'Elite‚ÜíStarter Drop', 'Top10‚ÜíStarter Drop', '# Elite Players'
            ]
            
            st.dataframe(scarcity_display, use_container_width=True)
            
            # Strategic insights
            st.subheader("üß† Strategic Insights")
            
            col1, col2, col3 = st.columns(3)
            
            with col1:
                most_scarce = scarcity_df.loc[scarcity_df['elite_to_starter_drop'].idxmax()]
                st.metric(
                    "üèÜ Most Scarce Position", 
                    most_scarce['position'],
                    f"{most_scarce['elite_to_starter_drop']} pt drop-off"
                )
            
            with col2:
                deepest_pos = scarcity_df.loc[scarcity_df['elite_to_starter_drop'].idxmin()]
                st.metric(
                    "üìä Deepest Position", 
                    deepest_pos['position'],
                    f"{deepest_pos['elite_to_starter_drop']} pt drop-off"
                )
            
            with col3:
                # Calculate which position has most elite options
                most_elite = scarcity_df.loc[scarcity_df['elite_count'].idxmax()]
                st.metric(
                    "üéØ Most Elite Options", 
                    most_elite['position'],
                    f"{most_elite['elite_count']} elite players"
                )
            
            # Draft strategy recommendations
            st.subheader("üìà Draft Strategy Implications")
            
            # Sort by scarcity
            scarcity_sorted = scarcity_df.sort_values('elite_to_starter_drop', ascending=False)
            
            st.write("**Based on positional scarcity analysis:**")
            
            most_scarce_pos = scarcity_sorted.iloc[0]['position']
            second_scarce_pos = scarcity_sorted.iloc[1]['position'] if len(scarcity_sorted) > 1 else "N/A"
            deepest_pos = scarcity_sorted.iloc[-1]['position']
            
            st.info(f"""
            üéØ **Priority 1:** Target elite {most_scarce_pos}s early - biggest drop-off from elite to average
            
            üéØ **Priority 2:** Consider elite {second_scarce_pos}s if available
            
            üéØ **Wait Strategy:** {deepest_pos} position has good depth - can wait until later rounds
            
            üìä **The Data Says:** Elite {most_scarce_pos}s provide {scarcity_sorted.iloc[0]['elite_to_starter_drop']:.1f} more points per game than average starters
            """)
        
        # Value Above Replacement Analysis
        st.subheader("‚ö° Value Above Replacement (VAR)")
        var_df = analyze_elite_vs_depth_strategy(filtered_df)
        
        if not var_df.empty:
            fig_var = px.bar(
                var_df.sort_values('elite_var', ascending=False),
                x='position',
                y='elite_var', 
                title='Elite Player Value Above Replacement Level',
                labels={
                    'elite_var': 'Points Above Replacement per Game',
                    'position': 'Position'
                }
            )
            st.plotly_chart(fig_var, use_container_width=True, key="fig_var")
            
            st.dataframe(var_df, use_container_width=True, key="var-df")
        
        # Weekly trends
        st.subheader("üìÖ Weekly Scoring Trends")
        weekly_trends = filtered_df.groupby(['week', 'position'])['player_fantasy_pts'].mean().reset_index()
        fig7 = px.line(weekly_trends, x='week', y='player_fantasy_pts',
                      color='position', title='Average Points by Week and Position')
        st.plotly_chart(fig7, use_container_width=True, key="weekly-trends_fig7")

if __name__ == "__main__":
    main()